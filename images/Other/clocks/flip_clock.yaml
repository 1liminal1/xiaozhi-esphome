display:
  - id: !extend main_display
    pages:
      - id: flip_clock_page
        lambda: |-
          // Base
          it.fill(Color::BLACK);

          // Optional background image (toggleable).
          // If you already have a switch for this (e.g. id(clock_show_background)),
          // keep this. If not, remove the if() and the "else" will keep black.
          #ifdef USE_BINARY_SENSOR
          if (id(clock_show_background).state) {
            it.image((it.get_width() / 2), (it.get_height() / 2), id(clock_background), ImageAlign::CENTER);
          }
          #endif

          const int W = it.get_width();
          const int H = it.get_height();
          const int cx = W / 2;
          const int cy = H / 2;

          // Colors
          float rr = id(clock_color_picker).current_values.get_red();
          float gg = id(clock_color_picker).current_values.get_green();
          float bb = id(clock_color_picker).current_values.get_blue();
          if (rr == 0.0f && gg == 0.0f && bb == 0.0f) { rr = gg = bb = 1.0f; } // default white
          const Color FG((uint8_t)(rr * 255.0f), (uint8_t)(gg * 255.0f), (uint8_t)(bb * 255.0f)); // digits & accents
          const Color PANEL_BG(20, 20, 20);
          const Color PANEL_EDGE(70, 70, 70);
          const Color HINGE(40, 40, 40);
          const Color COLON_DOT(180, 180, 180);

          // Time
          auto now = id(sntp_time).now();
          int hour = now.hour;
          if (!id(clock_24h).state) {
            hour %= 12;
            if (hour == 0) hour = 12;
          }
          int minute = now.minute;
          int sec = now.second;

          // Layout: four flip panels [H1][H2] : [M1][M2]
          const int margin = 10;
          const int gap = std::max(6, W / 80);           // gap between panels
          const int colon_gap = std::max(8, W / 60);     // colon spacing from panels
          const int panel_w = (W - 2*margin - 3*gap - 2*colon_gap) / 4;
          const int panel_h = std::min(H - 2*margin, panel_w * 1.6f); // tall-ish
          const int top = cy - panel_h/2;

          // Left edge of first panel so the whole cluster is centered
          const int total_w = 4*panel_w + 3*gap + 2*colon_gap;
          const int left = cx - total_w/2;

          // Digits
          int h1 = (hour / 10) % 10;
          int h2 = hour % 10;
          int m1 = (minute / 10) % 10;
          int m2 = minute % 10;

          // Helper to draw one flip panel
          auto draw_panel = [&](int x, int y, int w, int h, int digit) {
            // outer panel
            it.filled_rectangle(x, y, w, h, PANEL_BG);
            // border
            it.rectangle(x, y, w, h, PANEL_EDGE);

            // hinge (middle split line, plus tiny “pins”)
            int midy = y + h/2;
            it.hline(x+1, midy, w-2, HINGE);
            int pin_r = std::max(1, w / 40);
            it.filled_circle(x + w/6, midy, pin_r, HINGE);
            it.filled_circle(x + w - w/6, midy, pin_r, HINGE);

            // light/shadow bands to mimic flip halves
            int band = std::max(2, h / 20);
            it.filled_rectangle(x+1, y+1, w-2, band, Color(32,32,32));
            it.filled_rectangle(x+1, midy+1, w-2, band, Color(16,16,16));

            // digit text (centered)
            // Use your existing big mono clock font for best alignment.
            char buf[2]; buf[0] = '0' + digit; buf[1] = '\0';
            it.printf(x + w/2, y + h/2 - 1, id(font_big_clock_mono), FG, TextAlign::CENTER, "%s", buf);
          };

          // Draw the four panels
          int x1 = left;
          int x2 = x1 + panel_w + gap;
          int colon_x = x2 + panel_w + colon_gap;              // center line of colon
          int x3 = colon_x + colon_gap;
          int x4 = x3 + panel_w + gap;

          draw_panel(x1, top, panel_w, panel_h, h1);
          draw_panel(x2, top, panel_w, panel_h, h2);
          draw_panel(x3, top, panel_w, panel_h, m1);
          draw_panel(x4, top, panel_w, panel_h, m2);

          // Colon (blinks when seconds are shown, else steady)
          bool blink = id(clock_show_seconds).state && ((sec % 2) == 0);
          int colon_r = std::max(2, panel_w / 14);
          int colon_y_offset = panel_h / 6;
          if (!blink) {
            it.filled_circle(colon_x, cy - colon_y_offset, colon_r, COLON_DOT);
            it.filled_circle(colon_x, cy + colon_y_offset, colon_r, COLON_DOT);
          }

          // ---- Seconds progress dots (only when seconds switch is ON) ----
          if (id(clock_show_seconds).state) {
            const float PI = 3.1415926f;
            const int r_outer = (std::min(W, H) / 2) - std::max(6, W/50);
            // scale dot sizes
            const int dot_r = std::max(2, std::min(3, W / 180));

            // use a simple palette keyed off minute (same feel as your other clock)
            const Color minute_palette[10] = {
              Color(0x3b,0x89,0xe3), Color(0x26,0xed,0x3a), Color(0xff,0xc1,0x07),
              Color(0xff,0x5a,0x36), Color(0xff,0x3b,0x8d), Color(0x9c,0x27,0xb0),
              Color(0x00,0xbc,0xd4), Color(0x8b,0xc3,0x4a), Color(0xfe,0x6d,0x73),
              Color(0x60,0x7d,0x8b)
            };
            Color sec_col = minute_palette[minute % 10];

            // progress-style dots: 0..sec (NO special white markers every 5s)
            for (int i = 0; i <= sec && i < 60; i++) {
              float angle = (i / 60.0f) * 2.0f * PI - PI/2.0f;
              int x = cx + (int)(r_outer * cosf(angle));
              int y = cy + (int)(r_outer * sinf(angle));
              it.filled_circle(x, y, dot_r, sec_col);
            }
          }
