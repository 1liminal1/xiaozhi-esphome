display:
  - id: !extend main_display
    pages:
      - id: clock_page
        lambda: |-
          // --- base / optional wallpaper ---
          it.fill(Color::BLACK);
          if (id(clock_show_wallpaper).state) {
            it.image((it.get_width() / 2), (it.get_height() / 2), id(clock_wallpaper), ImageAlign::CENTER);
          }

          const int W = it.get_width();
          const int H = it.get_height();
          const int cx = W / 2;
          const int cy = H / 2;

          // Colors from HA color wheel
          float rr = id(clock_color_picker).current_values.get_red();
          float gg = id(clock_color_picker).current_values.get_green();
          float bb = id(clock_color_picker).current_values.get_blue();
          if (rr == 0.0f && gg == 0.0f && bb == 0.0f) { rr = gg = bb = 1.0f; }
          const Color FG((uint8_t)(rr * 255.0f), (uint8_t)(gg * 255.0f), (uint8_t)(bb * 255.0f));
          const Color PANEL_BG(20, 20, 20);
          const Color PANEL_EDGE(70, 70, 70);
          const Color HINGE(40, 40, 40);
          const Color COLON_DOT(180, 180, 180);

          auto now = id(sntp_time).now();
          int hour = now.hour;
          if (!id(clock_24h).state) {
            hour %= 12;
            if (hour == 0) hour = 12;
          }
          int minute = now.minute;
          int sec = now.second;

          // --- geometry (scales for 240x240, 360x360, etc.) ---
          const int gap       = std::max(6, W / 80);
          const int colon_gap = std::max(8, W / 60);

          // Dot ring geometry
          const int r_ring = (std::min(W, H) / 2) - std::max(6, W/50);   // dot center radius
          const int dot_r  = std::max(2, std::min(3, W / 180));

          // Keep panels inside the dots (safe spacing)
          const int ring_clearance = dot_r * 3 + 8;
          const int allowed_half   = r_ring - ring_clearance;
          const int max_content_w  = std::max(20, 2 * allowed_half);
          const int max_content_h  = std::max(20, 2 * allowed_half);

          // Unconstrained guess, then uniform scale to fit
          int panel_w_guess = (W - 3*gap - 2*colon_gap) / 4;
          int panel_h_guess = (int)(panel_w_guess * 1.6f);

          auto total_size_for = [&](int pw, int ph, int &tw, int &th) {
            tw = 4*pw + 3*gap + 2*colon_gap;
            th = ph;
          };

          int tw, th;
          total_size_for(panel_w_guess, panel_h_guess, tw, th);
          float sx = (float)max_content_w / (float)tw;
          float sy = (float)max_content_h / (float)th;
          float s  = std::min(1.0f, std::min(sx, sy) * 0.95f);  // small safety buffer

          const int panel_w = std::max(10, (int)(panel_w_guess * s));
          const int panel_h = std::max(16, (int)(panel_h_guess * s));
          total_size_for(panel_w, panel_h, tw, th);

          // Center the cluster
          const int left = cx - tw/2;
          const int top  = cy - panel_h/2;

          // Digits
          int h1 = (hour / 10) % 10;
          int h2 = hour % 10;
          int m1 = (minute / 10) % 10;
          int m2 = minute % 10;

          // --- helpers ---
          auto draw_panel = [&](int x, int y, int w, int h) {
            it.filled_rectangle(x, y, w, h, PANEL_BG);
            it.rectangle(x, y, w, h, PANEL_EDGE);
            int midy = y + h/2;
            it.line(x + 1, midy, x + 1 + (w - 2), midy, HINGE);   // hinge line
            int pin_r = std::max(1, w / 40);
            it.filled_circle(x + w/6, midy, pin_r, HINGE);
            it.filled_circle(x + w - w/6, midy, pin_r, HINGE);
            int band = std::max(2, h / 20);
            it.filled_rectangle(x+1, y+1, w-2, band, Color(32,32,32));
            it.filled_rectangle(x+1, midy+1, w-2, band, Color(16,16,16));
          };
          auto print_digit = [&](int x, int y, int w, int h, int digit) {
            char buf[2]; buf[0] = '0' + digit; buf[1] = '\0';
            it.printf(x + w/2, y + h/2 - 1, id(font_big_clock_mono), FG, TextAlign::CENTER, "%s", buf);
          };

          // Panel positions
          int x1 = left;
          int x2 = x1 + panel_w + gap;
          int colon_x = x2 + panel_w + colon_gap;
          int x3 = colon_x + colon_gap;
          int x4 = x3 + panel_w + gap;

          // Draw panels + digits
          draw_panel(x1, top, panel_w, panel_h); print_digit(x1, top, panel_w, panel_h, h1);
          draw_panel(x2, top, panel_w, panel_h); print_digit(x2, top, panel_w, panel_h, h2);
          draw_panel(x3, top, panel_w, panel_h); print_digit(x3, top, panel_w, panel_h, m1);
          draw_panel(x4, top, panel_w, panel_h); print_digit(x4, top, panel_w, panel_h, m2);

          // Colon (blink when seconds ON; steady otherwise)
          bool blink = id(clock_show_seconds).state && ((sec % 2) == 0);
          int colon_r = std::max(2, panel_w / 14);
          int colon_y_offset = panel_h / 6;
          if (!blink) {
            it.filled_circle(colon_x, cy - colon_y_offset, colon_r, COLON_DOT);
            it.filled_circle(colon_x, cy + colon_y_offset, colon_r, COLON_DOT);
          }

          // --- precomputed unit circle (once) to avoid per-frame trig ---
          static bool LUT_INIT = false;
          static int16_t ux[60];   // cos * 10000
          static int16_t uy[60];   // sin * 10000
          if (!LUT_INIT) {
            const float TWO_PI = 6.2831853f;
            for (int i = 0; i < 60; i++) {
              float a = (i / 60.0f) * TWO_PI - (3.1415926f / 2.0f);
              // scale to fixed-point to avoid floats later
              ux[i] = (int16_t) lroundf(cosf(a) * 10000.0f);
              uy[i] = (int16_t) lroundf(sinf(a) * 10000.0f);
            }
            LUT_INIT = true;
          }

          // --- thin black ring + progress dots (no white 5s markers) ---
          if (id(clock_show_seconds).state) {
            // 1) clear just the rim with a thin BLACK annulus
            const int erase_thickness = dot_r * 2 + 2;   // must cover previous dots fully
            const int r_in  = r_ring - erase_thickness/2;
            const int r_out = r_ring + erase_thickness/2;
            for (int rr = r_in; rr <= r_out; rr++) {
              it.circle(cx, cy, rr, Color::BLACK);
            }

            // 2) minute-based color
            const Color minute_palette[10] = {
              Color(0x3b,0x89,0xe3), Color(0x26,0xed,0x3a), Color(0xff,0xc1,0x07),
              Color(0xff,0x5a,0x36), Color(0xff,0x3b,0x8d), Color(0x9c,0x27,0xb0),
              Color(0x00,0xbc,0xd4), Color(0x8b,0xc3,0x4a), Color(0xfe,0x6d,0x73),
              Color(0x60,0x7d,0x8b)
            };
            Color sec_col = minute_palette[minute % 10];

            // 3) draw progress dots using LUT (no per-frame sin/cos)
            for (int i = 0; i <= sec && i < 60; i++) {
              int x = cx + (int)(( (long)r_ring * ux[i]) / 10000L);
              int y = cy + (int)(( (long)r_ring * uy[i]) / 10000L);
              it.filled_circle(x, y, dot_r, sec_col);
            }
          }
