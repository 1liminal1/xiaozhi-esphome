display:
  - id: !extend main_display
    pages:
      - id: clock_page
        lambda: |-
          // ==== Lively Robo Eyes â€” low CPU, compile-safe ====
          const uint32_t FRAME_MS_FAST = 120;   // faster while moving
          const uint32_t FRAME_MS_IDLE = 300;   // chill when idle

          // Geometry
          const int W = it.get_width();
          const int H = it.get_height();
          const int cx = W / 2;
          const int cy = H / 2;
          const int eye_gap = std::max(22, W / 8);
          const int R = std::min(W, H) / 6;
          const int base_lx = cx - eye_gap;
          const int base_rx = cx + eye_gap;
          const int base_ey = cy;

          // Helpers (each self-contained)
          auto lcg = [](uint32_t &s)->uint32_t { s = s * 1664525u + 1013904223u; return s; };
          auto frand = [&](uint32_t &s, float a, float b)->float { return a + (float)(lcg(s) & 0xFFFF) / 65535.0f * (b - a); };
          auto clampf = [](float v, float a, float b)->float { return v < a ? a : (v > b ? b : v); };
          auto lerp = [](float a, float b, float t)->float { return a + (b - a) * t; };
          auto tri01 = [](uint32_t t, uint32_t period)->float { uint32_t x=t%period; float f=(float)x/(float)period; return (x<period/2)?(2.0f*f):(2.0f-2.0f*f); };
          auto ease_inout = [](float t)->float { return (t<0.5f) ? (2.0f*t*t) : (1.0f - powf(-2.0f*t+2.0f,2.0f)/2.0f); };

          // State
          enum Mode { SLEEPY, WAKE, IDLE, BLINK, LOOK, SQUINT, SURPRISED };
          struct EyesState {
            bool init;
            uint32_t rng;
            uint32_t last_ms;
            uint32_t next_ms;      // self-throttle
            Mode mode;
            float t, dur;
            float open;            // eyelid 0..1
            float px, py;          // look dir -1..1
            float tx, ty;          // target look
            // prev for dirty-erase / early-out
            int prev_lx, prev_rx, prev_ey;
            int prev_open_px;
            int prev_ix_l, prev_iy_l, prev_ix_r, prev_iy_r;
            int prev_led_g;
            bool bg_clear;
          };
          static EyesState s;
          uint32_t now_ms = millis();

          if (!s.init) {
            s.init = true;
            s.rng = 0xC0FFEEu ^ now_ms;
            s.last_ms = now_ms;
            s.next_ms = 0;
            s.mode = SLEEPY;
            s.t = 0.0f; s.dur = 2.4f;
            s.open = 0.08f;
            s.px = s.py = 0.0f;
            s.tx = s.ty = 0.0f;
            s.prev_lx = s.prev_rx = s.prev_ey = -9999;
            s.prev_open_px = -1;
            s.prev_ix_l = s.prev_iy_l = s.prev_ix_r = s.prev_iy_r = -9999;
            s.prev_led_g = -1;
            s.bg_clear = false;
          }

          // page-level throttle
          if (now_ms < s.next_ms) return;

          // clear once (no full-screen clears every frame)
          if (!s.bg_clear) {
            it.fill(Color::BLACK);
            s.bg_clear = true;
          }

          // fixed logical step so it looks smooth even at 300ms
          float dt = (now_ms - s.last_ms) / 1000.0f;
          if (dt < 0.0f || dt > 0.7f) dt = 0.2f;
          s.last_ms = now_ms;
          s.t += 0.2f;

          // transitions
          auto goto_mode = [&](Mode m, float duration){ s.mode = m; s.t = 0.0f; s.dur = duration; };
          auto pick_idle_action = [&](){
            float r = frand(s.rng, 0.0f, 1.0f);
            if      (r < 0.25f) goto_mode(BLINK, frand(s.rng, 0.18f, 0.28f));
            else if (r < 0.65f) { s.tx = frand(s.rng,-0.8f,0.8f); s.ty = frand(s.rng,-0.6f,0.6f); goto_mode(LOOK, frand(s.rng,0.5f,1.2f)); }
            else if (r < 0.85f) goto_mode(SQUINT, frand(s.rng, 0.6f, 1.0f));
            else                 goto_mode(SURPRISED, frand(s.rng, 0.5f, 0.9f));
          };

          // per-mode logic (kept close to your original; SLEEPY uses cheap tri wave)
          switch (s.mode) {
            case SLEEPY: {
              float phase = 0.07f + 0.05f * tri01(now_ms, 4000); // cheaper than sinf
              s.open = clampf(phase, 0.0f, 0.12f);
              s.px = lerp(s.px, 0.0f, 0.02f);
              s.py = lerp(s.py, 0.2f, 0.02f);
              if (s.t > s.dur) goto_mode(WAKE, 0.8f);
            } break;

            case WAKE: {
              float k = ease_inout(clampf(s.t / s.dur, 0.0f, 1.0f));
              s.open = lerp(0.08f, 1.0f, k);
              s.px = lerp(s.px, 0.0f, 0.08f);
              s.py = lerp(s.py, 0.0f, 0.08f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.5f, 3.0f));
            } break;

            case IDLE: {
              s.open = lerp(s.open, 0.95f, 0.02f);
              s.tx += frand(s.rng, -0.02f, 0.02f);
              s.ty += frand(s.rng, -0.02f, 0.02f);
              s.tx = clampf(s.tx, -0.35f, 0.35f);
              s.ty = clampf(s.ty, -0.25f, 0.25f);
              s.px = lerp(s.px, s.tx, 0.05f);
              s.py = lerp(s.py, s.ty, 0.05f);
              if (s.t >= s.dur) pick_idle_action();
            } break;

            case BLINK: {
              float k = s.t / s.dur;
              s.open = (k < 0.5f) ? lerp(1.0f, 0.0f, k*2.0f) : lerp(0.0f, 1.0f, (k-0.5f)*2.0f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.2f));
            } break;

            case LOOK: {
              s.open = lerp(s.open, 0.95f, 0.05f);
              s.px = lerp(s.px, s.tx, 0.10f);
              s.py = lerp(s.py, s.ty, 0.10f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;

            case SQUINT: {
              float k = 0.5f - 0.5f*cosf(clampf(s.t / s.dur, 0.0f, 1.0f) * 3.14159f);
              float target = lerp(0.55f, 0.25f, (k<0.5f) ? (k*2.0f) : (1.0f - (k-0.5f)*2.0f));
              s.open = lerp(s.open, target, 0.35f);
              s.px = lerp(s.px, 0.0f, 0.08f);
              s.py = lerp(s.py, 0.0f, 0.08f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;

            case SURPRISED: {
              s.open = lerp(s.open, 1.0f, 0.25f);
              s.px = lerp(s.px, frand(s.rng, -0.15f, 0.15f), 0.08f);
              s.py = lerp(s.py, frand(s.rng, -0.05f, 0.0f),  0.08f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;
          }

          // positions
          float eye_shift_x = R * 0.20f;
          float eye_shift_y = R * 0.12f;
          int lx = base_lx + (int)(s.px * eye_shift_x);
          int rx = base_rx + (int)(s.px * eye_shift_x);
          int ey = base_ey + (int)(s.py * eye_shift_y);

          // openness and pupils
          int open_px = (int)(R * clampf(s.open, 0.0f, 1.0f));
          float max_off = R * 0.38f * (s.open); // constrain by eyelids
          // tiny jitter to feel alive
          float jx = 0.0f, jy = 0.0f;
          if (s.mode == IDLE || s.mode == LOOK || s.mode == SURPRISED) {
            jx = frand(s.rng, -0.03f, 0.03f);
            jy = frand(s.rng, -0.03f, 0.03f);
          }
          int ix_l = lx + (int)(clampf(s.px + jx, -1.0f, 1.0f) * max_off);
          int iy_l = ey + (int)(clampf(s.py + jy, -1.0f, 1.0f) * max_off);
          int ix_r = rx + (int)(clampf(s.px + jx, -1.0f, 1.0f) * max_off);
          int iy_r = ey + (int)(clampf(s.py + jy, -1.0f, 1.0f) * max_off);

          // center LED (triangle wave, cheap)
          float beat = 0.35f + 0.65f * tri01(now_ms, 1600);
          int led_g = (int)(100 + 120 * beat);
          int led_r = std::max(2, R / 6);
          int led_x = cx, led_y = ey + R + 8;

          // early-out if nothing changed (incl LED)
          if (lx == s.prev_lx && rx == s.prev_rx && ey == s.prev_ey &&
              open_px == s.prev_open_px &&
              ix_l == s.prev_ix_l && iy_l == s.prev_iy_l &&
              ix_r == s.prev_ix_r && iy_r == s.prev_iy_r &&
              led_g == s.prev_led_g) {
            s.next_ms = now_ms + FRAME_MS_IDLE;
            return;
          }

          // erase previous eye boxes and LED box (dirty rectangles)
          auto erase_eye_box = [&](int ex, int eyc){
            int box = (R + 2);
            it.filled_rectangle(ex - box, eyc - box, box*2, box*2, Color::BLACK);
          };
          if (s.prev_lx != -9999) {
            erase_eye_box(s.prev_lx, s.prev_ey);
            erase_eye_box(s.prev_rx, s.prev_ey);
            int lbox = led_r + 2;
            it.filled_rectangle(led_x - lbox, (s.prev_ey + R + 8) - lbox, lbox*2, lbox*2, Color::BLACK);
          }

          // draw eyes (reduced draw calls)
          auto draw_eye = [&](int ex, int eyc, int radius, int open_px, int ix, int iy) {
            // sclera
            it.filled_circle(ex, eyc, radius, Color::WHITE);

            // eyelids mask
            int cover = radius - open_px;
            if (cover > 0) {
              it.filled_rectangle(ex - radius - 1, eyc - radius - 1, radius*2 + 2, cover + 1, Color::BLACK);
              it.filled_rectangle(ex - radius - 1, eyc + open_px,     radius*2 + 2, radius - open_px + 1, Color::BLACK);
            }

            // iris + pupil
            int iris_r  = std::max(2, (int)(radius * 0.46f));
            int pupil_r = std::max(1, (int)(radius * 0.18f));
            Color iris_in(0x80,0xc8,0xff), iris_outline(0x30,0x70,0xa0);
            it.filled_circle(ix, iy, iris_r, iris_in);
            it.circle(ix, iy, iris_r, iris_outline);

            // simple 4 spokes (no trig)
            it.line(ix, iy, ix + (iris_r-2), iy, iris_outline);
            it.line(ix, iy, ix - (iris_r-2), iy, iris_outline);
            it.line(ix, iy, ix, iy + (iris_r-2), iris_outline);
            it.line(ix, iy, ix, iy - (iris_r-2), iris_outline);

            it.filled_circle(ix, iy, pupil_r, Color::BLACK);
            it.filled_circle(ix - pupil_r/2, iy - pupil_r, std::max(1, pupil_r/3), Color::WHITE);

            // single rim (lighter than triple)
            Color rim(0x90,0x90,0x90);
            it.circle(ex, eyc, radius, rim);
          };

          draw_eye(lx, ey, R, open_px, ix_l, iy_l);
          draw_eye(rx, ey, R, open_px, ix_r, iy_r);

          // LED
          it.filled_circle(led_x, led_y, led_r, Color((uint8_t)30, (uint8_t)led_g, (uint8_t)255));

          // save + adaptive cadence
          bool moving = (s.mode != IDLE);
          s.prev_lx = lx; s.prev_rx = rx; s.prev_ey = ey;
          s.prev_open_px = open_px;
          s.prev_ix_l = ix_l; s.prev_iy_l = iy_l; s.prev_ix_r = ix_r; s.prev_iy_r = iy_r;
          s.prev_led_g = led_g;
          s.next_ms = now_ms + (moving ? FRAME_MS_FAST : FRAME_MS_IDLE);
