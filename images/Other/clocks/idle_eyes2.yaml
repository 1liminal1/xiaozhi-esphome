display:
  - id: !extend main_display
    pages:
      - id: clock_page
        lambda: |-
          // ==== Low-CPU Lively Robo Eyes (self-throttled) ====
          // - Adaptive cadence: fast while moving, ~300ms when idle
          // - Dirty-rect redraw (no full-screen clear)
          // - Extra behaviors: wink (L/R), micro-saccades, surprised/squint/looks

          // ----------------- CONFIG -----------------
          const uint32_t FRAME_MS_FAST = 120;   // ~8–10 fps while moving
          const uint32_t FRAME_MS_IDLE = 300;   // ~3 fps when idle (safe for OTA/MWW)
          const int SPOKES = 4;                 // fewer iris spokes (less draw calls)

          // ----------------- GEOMETRY -----------------
          const int W = it.get_width();
          const int H = it.get_height();
          const int cx = W / 2;
          const int cy = H / 2;

          const int eye_gap = std::max(22, W / 8);
          const int R = std::min(W, H) / 6;
          const int base_lx = cx - eye_gap;
          const int base_rx = cx + eye_gap;
          const int base_ey = cy;

          // ----------------- HELPERS (self-contained) -----------------
          auto clampf = [](float v, float a, float b)->float { return v < a ? a : (v > b ? b : v); };
          auto clamp01 = [](float t)->float { return (t < 0.0f) ? 0.0f : (t > 1.0f ? 1.0f : t); };
          auto lerp   = [](float a, float b, float t)->float { return a + (b - a) * t; };
          auto ease_smooth = [](float t)->float { t = (t < 0.0f) ? 0.0f : (t > 1.0f ? 1.0f : t); return t*t*(3.0f - 2.0f*t); }; // smoothstep
          auto tri01  = [](uint32_t t, uint32_t period)->float { uint32_t x = t % period; float f = (float)x/(float)period; return (x < period/2) ? (2.0f*f) : (2.0f - 2.0f*f); };
          auto lcg    = [](uint32_t &s)->uint32_t { s = s * 1664525u + 1013904223u; return s; };
          auto frand  = [&](uint32_t &s, float a, float b)->float { return a + (float)(lcg(s) & 0xFFFF) / 65535.0f * (b - a); };

          // ----------------- STATE -----------------
          enum Mode { SLEEPY, WAKE, IDLE, BLINK, WINK_L, WINK_R, LOOK, SQUINT, SURPRISED };

          struct S {
            bool init;
            uint32_t rng, last_ms, next_ms;
            Mode mode;
            float t, dur;
            float open_l, open_r;    // per-eye 0..1
            float px, py;            // look dir -1..1
            float tx, ty;            // target look
            // previous pixels for dirty-rect + early-out
            int prev_lx, prev_rx, prev_ey;
            int prev_open_px_l, prev_open_px_r;
            int prev_ix_l, prev_iy_l, prev_ix_r, prev_iy_r;
            // LED
            int prev_led_g;
            bool bg_clear;
          };
          static S s;
          uint32_t now = millis();

          if (!s.init) {
            s.init = true;
            s.rng = 0xC0FFEEu ^ now;
            s.last_ms = now;
            s.next_ms = 0;
            s.mode = SLEEPY;
            s.t = 0.0f; s.dur = 2.2f;
            s.open_l = s.open_r = 0.08f;
            s.px = s.py = s.tx = s.ty = 0.0f;
            s.prev_lx = s.prev_rx = s.prev_ey = -9999;
            s.prev_open_px_l = s.prev_open_px_r = -1;
            s.prev_ix_l = s.prev_iy_l = s.prev_ix_r = s.prev_iy_r = -9999;
            s.prev_led_g = -1;
            s.bg_clear = false;
          }

          // Page-level throttle (self FPS)
          if (now < s.next_ms) return;

          // One-time clear (don’t clear every frame)
          if (!s.bg_clear) {
            it.fill(Color::BLACK);
            s.bg_clear = true;
          }

          // Fixed logical step (stable at low framerates)
          float rt = (now - s.last_ms) / 1000.0f;
          if (rt < 0.0f || rt > 0.7f) rt = 0.2f;
          s.last_ms = now;
          s.t += 0.2f;

          // --------------- TRANSITIONS ---------------
          auto goto_mode = [&](Mode m, float d){ s.mode = m; s.t = 0.0f; s.dur = d; };
          auto pick_idle_action = [&](){
            float r = frand(s.rng, 0.0f, 1.0f);
            if      (r < 0.18f) goto_mode(BLINK,   frand(s.rng, 0.18f, 0.28f));
            else if (r < 0.28f) goto_mode(WINK_L,  frand(s.rng, 0.18f, 0.28f));
            else if (r < 0.38f) goto_mode(WINK_R,  frand(s.rng, 0.18f, 0.28f));
            else if (r < 0.80f) { s.tx = frand(s.rng,-0.8f,0.8f); s.ty = frand(s.rng,-0.6f,0.6f); goto_mode(LOOK, frand(s.rng,0.5f,1.1f)); }
            else if (r < 0.92f) goto_mode(SQUINT,  frand(s.rng, 0.6f, 1.0f));
            else                 goto_mode(SURPRISED, frand(s.rng, 0.4f, 0.8f));
          };

          // --------------- BEHAVIOR ---------------
          switch (s.mode) {
            case SLEEPY: {
              // eyelids “breathe” using triangle wave (cheap)
              float phase = 0.07f + 0.05f * tri01(now, 4000);
              s.open_l = s.open_r = clampf(phase, 0.0f, 0.12f);
              s.px = lerp(s.px, 0.0f, 0.08f);
              s.py = lerp(s.py, 0.20f, 0.08f);
              if (s.t > s.dur) goto_mode(WAKE, 0.8f);
            } break;

            case WAKE: {
              float k = ease_smooth(s.t / s.dur);
              s.open_l = s.open_r = lerp(0.10f, 1.0f, k);
              s.px = lerp(s.px, 0.0f, 0.15f);
              s.py = lerp(s.py, 0.0f, 0.15f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.5f, 3.0f));
            } break;

            case IDLE: {
              s.open_l = s.open_r = lerp(s.open_l, 0.95f, 0.12f);
              // gentle drift (step-sampled)
              s.tx = clampf(s.tx + frand(s.rng, -0.06f, 0.06f), -0.35f, 0.35f);
              s.ty = clampf(s.ty + frand(s.rng, -0.04f, 0.04f), -0.25f, 0.25f);
              s.px = lerp(s.px, s.tx, 0.25f);
              s.py = lerp(s.py, s.ty, 0.25f);
              if (s.t >= s.dur) pick_idle_action();
            } break;

            case BLINK: {
              float k = s.t / s.dur;
              float o = (k < 0.5f) ? (1.0f - k*2.0f) : ((k-0.5f)*2.0f);
              o = clamp01(o);
              s.open_l = s.open_r = o;
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.2f));
            } break;

            case WINK_L: {
              float k = s.t / s.dur;
              float o = (k < 0.5f) ? (1.0f - k*2.0f) : ((k-0.5f)*2.0f);
              s.open_l = clamp01(o); s.open_r = 1.0f;
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;

            case WINK_R: {
              float k = s.t / s.dur;
              float o = (k < 0.5f) ? (1.0f - k*2.0f) : ((k-0.5f)*2.0f);
              s.open_r = clamp01(o); s.open_l = 1.0f;
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;

            case LOOK: {
              s.open_l = s.open_r = lerp(s.open_l, 0.95f, 0.25f);
              s.px = lerp(s.px, s.tx, 0.35f);
              s.py = lerp(s.py, s.ty, 0.35f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;

            case SQUINT: {
              float k = ease_smooth(s.t / s.dur);
              float mid = (k < 0.5f) ? (k*2.0f) : (1.0f - (k-0.5f)*2.0f);
              float target = lerp(0.55f, 0.25f, mid);
              s.open_l = s.open_r = lerp(s.open_l, target, 0.6f);
              s.px = lerp(s.px, 0.0f, 0.2f);
              s.py = lerp(s.py, 0.0f, 0.2f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;

            case SURPRISED: {
              s.open_l = s.open_r = lerp(s.open_l, 1.0f, 0.5f);
              s.px = lerp(s.px, frand(s.rng, -0.12f, 0.12f), 0.25f);
              s.py = lerp(s.py, frand(s.rng, -0.04f, 0.02f),  0.25f);
              if (s.t >= s.dur) goto_mode(IDLE, frand(s.rng, 1.0f, 2.0f));
            } break;
          }

          // Whole-eye drift
          int eye_shift_x = (int)(R * 0.20f * s.px);
          int eye_shift_y = (int)(R * 0.12f * s.py);
          int lx = base_lx + eye_shift_x;
          int rx = base_rx + eye_shift_x;
          int ey = base_ey + eye_shift_y;

          // Pupil positions (stay inside eyelids)
          auto open_to_px = [&](float o)->int { o = clamp01(o); return (int)(R * o); };
          int open_px_l = open_to_px(s.open_l);
          int open_px_r = open_to_px(s.open_r);

          float max_off = R * 0.38f * ((s.open_l + s.open_r)*0.5f);
          // micro-saccades (tiny jitter only in active-ish modes)
          float jx = 0.0f, jy = 0.0f;
          if (s.mode == IDLE || s.mode == LOOK || s.mode == SURPRISED) {
            jx = frand(s.rng, -0.03f, 0.03f);
            jy = frand(s.rng, -0.03f, 0.03f);
          }
          int ix_l = lx + (int)(clampf(s.px + jx, -1.0f, 1.0f) * max_off);
          int iy_l = ey + (int)(clampf(s.py + jy, -1.0f, 1.0f) * max_off);
          int ix_r = rx + (int)(clampf(s.px + jx, -1.0f, 1.0f) * max_off);
          int iy_r = ey + (int)(clampf(s.py + jy, -1.0f, 1.0f) * max_off);

          // LED pulsing (triangle wave)
          float beat = 0.35f + 0.65f * tri01(now, 1600);
          int led_g = (int)(100 + 120 * beat);
          int led_r = std::max(2, R / 6);
          int led_x = cx, led_y = ey + R + 8;

          // If nothing changed (including LED), skip draw entirely
          if (lx == s.prev_lx && rx == s.prev_rx && ey == s.prev_ey &&
              open_px_l == s.prev_open_px_l && open_px_r == s.prev_open_px_r &&
              ix_l == s.prev_ix_l && iy_l == s.prev_iy_l &&
              ix_r == s.prev_ix_r && iy_r == s.prev_iy_r &&
              led_g == s.prev_led_g) {
            s.next_ms = now + FRAME_MS_IDLE;
            return;
          }

          // --------------- DIRTY ERASE of previous regions ---------------
          auto erase_eye_box = [&](int ex, int eyc){
            int box = (R + 2);
            it.filled_rectangle(ex - box, eyc - box, box*2, box*2, Color::BLACK);
          };
          if (s.prev_lx != -9999) {
            erase_eye_box(s.prev_lx, s.prev_ey);
            erase_eye_box(s.prev_rx, s.prev_ey);
            // erase old LED area (small box)
            int lbox = led_r + 2;
            it.filled_rectangle(led_x - lbox, (s.prev_ey + R + 8) - lbox, lbox*2, lbox*2, Color::BLACK);
          }

          // --------------- DRAW ONE EYE (reduced calls) ---------------
          auto draw_eye = [&](int ex, int eyc, int open_px, int ix, int iy){
            // sclera
            it.filled_circle(ex, eyc, R, Color::WHITE);
            // eyelids mask (top/bot)
            int cover = R - open_px;
            if (cover > 0) {
              it.filled_rectangle(ex - R - 1, eyc - R - 1, (R*2)+2, cover + 1, Color::BLACK);
              it.filled_rectangle(ex - R - 1, eyc + open_px, (R*2)+2, R - open_px + 1, Color::BLACK);
            }
            // iris + pupil
            int iris_r  = std::max(2, (int)(R * 0.46f));
            int pupil_r = std::max(1, (int)(R * 0.18f));
            Color iris_in(0x80,0xc8,0xff), iris_outline(0x30,0x70,0xa0);
            it.filled_circle(ix, iy, iris_r, iris_in);
            it.circle(ix, iy, iris_r, iris_outline);
            // simple spokes (no trig)
            if (SPOKES >= 1) it.line(ix, iy, ix + (iris_r-2), iy, iris_outline);
            if (SPOKES >= 2) it.line(ix, iy, ix - (iris_r-2), iy, iris_outline);
            if (SPOKES >= 3) it.line(ix, iy, ix, iy + (iris_r-2), iris_outline);
            if (SPOKES >= 4) it.line(ix, iy, ix, iy - (iris_r-2), iris_outline);
            it.filled_circle(ix, iy, pupil_r, Color::BLACK);
            it.filled_circle(ix - pupil_r/2, iy - pupil_r, std::max(1, pupil_r/3), Color::WHITE);
            // single rim (lighter than triple)
            it.circle(ex, eyc, R, Color(0x90,0x90,0x90));
          };

          draw_eye(lx, ey, open_px_l, ix_l, iy_l);
          draw_eye(rx, ey, open_px_r, ix_r, iy_r);

          // LED (center)
          it.filled_circle(led_x, led_y, led_r, Color((uint8_t)30, (uint8_t)led_g, (uint8_t)255));

          // --------------- SAVE + ADAPT CADENCE ---------------
          bool moving = (s.mode != IDLE);
          s.prev_lx = lx; s.prev_rx = rx; s.prev_ey = ey;
          s.prev_open_px_l = open_px_l; s.prev_open_px_r = open_px_r;
          s.prev_ix_l = ix_l; s.prev_iy_l = iy_l; s.prev_ix_r = ix_r; s.prev_iy_r = iy_r;
          s.prev_led_g = led_g;
          s.next_ms = now + (moving ? FRAME_MS_FAST : FRAME_MS_IDLE);
