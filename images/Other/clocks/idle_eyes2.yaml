display:
  - id: !extend main_display
    pages:
      - id: clock_page
        lambda: |-
          // ==== Low-CPU Lively Robo Eyes (compile-safe) ====
          // - Adaptive cadence: ~120 ms while moving, ~300 ms when idle
          // - Dirty-rect redraw (no full-screen fill each frame)
          // - No lambda references another lambda (fixes your compile error)

          // -------- CONFIG --------
          const uint32_t FRAME_MS_FAST = 120;   // bump to 80â€“100 for snappier glances
          const uint32_t FRAME_MS_IDLE = 300;   // keep ~300 for low load

          // -------- GEOMETRY --------
          const int W = it.get_width();
          const int H = it.get_height();
          const int cx = W / 2;
          const int cy = H / 2;

          const int eye_gap = std::max(22, W / 8);
          const int R = std::min(W, H) / 6;
          const int base_lx = cx - eye_gap;
          const int base_rx = cx + eye_gap;
          const int base_ey = cy;

          // -------- HELPERS (self-contained) --------
          auto h_clampf   = [](float v, float a, float b)->float { return v < a ? a : (v > b ? b : v); };
          auto h_clamp01  = [](float t)->float { return (t < 0.0f) ? 0.0f : (t > 1.0f ? 1.0f : t); };
          auto h_lerp     = [](float a, float b, float t)->float { return a + (b - a) * t; };
          auto h_smooth01 = [](float t)->float {                 // smoothstep(0..1), no other helpers
            if (t < 0.0f) t = 0.0f; else if (t > 1.0f) t = 1.0f;
            return t*t*(3.0f - 2.0f*t);
          };
          auto h_tri01    = [](uint32_t t, uint32_t period)->float {
            uint32_t x = t % period; float f = (float)x/(float)period;
            return (x < period/2) ? (2.0f*f) : (2.0f - 2.0f*f);
          };
          auto h_lcg      = [](uint32_t &s)->uint32_t { s = s * 1664525u + 1013904223u; return s; };
          auto h_frand    = [&](uint32_t &s, float a, float b)->float {
            uint32_t r = h_lcg(s);
            return a + (float)(r & 0xFFFF) / 65535.0f * (b - a);
          };

          // -------- STATE --------
          enum Mode { SLEEPY, WAKE, IDLE, BLINK, WINK_L, WINK_R, LOOK, SQUINT, SURPRISED };
          struct S {
            bool init;
            uint32_t rng, last_ms, next_ms;
            Mode mode;
            float t, dur;
            float open_l, open_r;        // 0..1
            float px, py, tx, ty;        // look dirs
            // previous pixels for dirty-rect + early-out
            int prev_lx, prev_rx, prev_ey;
            int prev_open_px_l, prev_open_px_r;
            int prev_ix_l, prev_iy_l, prev_ix_r, prev_iy_r;
            int prev_led_g;
            bool bg_clear;
          };
          static S s;
          uint32_t now = millis();

          if (!s.init) {
            s.init = true;
            s.rng = 0xC0FFEEu ^ now;
            s.last_ms = now;
            s.next_ms = 0;
            s.mode = SLEEPY;
            s.t = 0.0f; s.dur = 2.2f;
            s.open_l = s.open_r = 0.08f;
            s.px = s.py = s.tx = s.ty = 0.0f;
            s.prev_lx = s.prev_rx = s.prev_ey = -9999;
            s.prev_open_px_l = s.prev_open_px_r = -1;
            s.prev_ix_l = s.prev_iy_l = s.prev_ix_r = s.prev_iy_r = -9999;
            s.prev_led_g = -1;
            s.bg_clear = false;
          }

          // self-throttle
          if (now < s.next_ms) return;

          // first frame clear only
          if (!s.bg_clear) {
            it.fill(Color::BLACK);
            s.bg_clear = true;
          }

          // fixed logical step (looks good even at 300ms)
          float rt = (now - s.last_ms) / 1000.0f;
          if (rt < 0.0f || rt > 0.7f) rt = 0.2f;
          s.last_ms = now;
          s.t += 0.2f;

          auto goto_mode = [&](Mode m, float d){ s.mode = m; s.t = 0.0f; s.dur = d; };
          auto pick_idle = [&](){
            float r = h_frand(s.rng, 0.0f, 1.0f);
            if      (r < 0.18f) goto_mode(BLINK,    h_frand(s.rng, 0.18f, 0.28f));
            else if (r < 0.28f) goto_mode(WINK_L,   h_frand(s.rng, 0.18f, 0.28f));
            else if (r < 0.38f) goto_mode(WINK_R,   h_frand(s.rng, 0.18f, 0.28f));
            else if (r < 0.80f) { s.tx = h_frand(s.rng,-0.8f,0.8f); s.ty = h_frand(s.rng,-0.6f,0.6f); goto_mode(LOOK, h_frand(s.rng,0.5f,1.1f)); }
            else if (r < 0.92f) goto_mode(SQUINT,   h_frand(s.rng, 0.6f, 1.0f));
            else                 goto_mode(SURPRISED,h_frand(s.rng, 0.4f, 0.8f));
          };

          // -------- BEHAVIOUR --------
          switch (s.mode) {
            case SLEEPY: {
              float phase = 0.07f + 0.05f * h_tri01(now, 4000);
              s.open_l = s.open_r = h_clampf(phase, 0.0f, 0.12f);
              s.px = h_lerp(s.px, 0.0f, 0.08f);
              s.py = h_lerp(s.py, 0.20f, 0.08f);
              if (s.t > s.dur) goto_mode(WAKE, 0.8f);
            } break;

            case WAKE: {
              float k = h_smooth01(s.t / s.dur);
              s.open_l = s.open_r = h_lerp(0.10f, 1.0f, k);
              s.px = h_lerp(s.px, 0.0f, 0.15f);
              s.py = h_lerp(s.py, 0.0f, 0.15f);
              if (s.t >= s.dur) goto_mode(IDLE, h_frand(s.rng, 1.5f, 3.0f));
            } break;

            case IDLE: {
              s.open_l = s.open_r = h_lerp(s.open_l, 0.95f, 0.12f);
              s.tx = h_clampf(s.tx + h_frand(s.rng, -0.06f, 0.06f), -0.35f, 0.35f);
              s.ty = h_clampf(s.ty + h_frand(s.rng, -0.04f, 0.04f), -0.25f, 0.25f);
              s.px = h_lerp(s.px, s.tx, 0.25f);
              s.py = h_lerp(s.py, s.ty, 0.25f);
              if (s.t >= s.dur) pick_idle();
            } break;

            case BLINK: {
              float k = s.t / s.dur;
              float o = (k < 0.5f) ? (1.0f - k*2.0f) : ((k-0.5f)*2.0f);
              o = h_clamp01(o);
              s.open_l = s.open_r = o;
              if (s.t >= s.dur) goto_mode(IDLE, h_frand(s.rng, 1.0f, 2.2f));
            } break;

            case WINK_L: {
              float k = s.t / s.dur;
              float o = (k < 0.5f) ? (1.0f - k*2.0f) : ((k-0.5f)*2.0f);
              s.open_l = h_clamp01(o); s.open_r = 1.0f;
              if (s.t >= s.dur) goto_mode(IDLE, h_frand(s.rng, 1.0f, 2.0f));
            } break;

            case WINK_R: {
              float k = s.t / s.dur;
              float o = (k < 0.5f) ? (1.0f - k*2.0f) : ((k-0.5f)*2.0f);
              s.open_r = h_clamp01(o); s.open_l = 1.0f;
              if (s.t >= s.dur) goto_mode(IDLE, h_frand(s.rng, 1.0f, 2.0f));
            } break;

            case LOOK: {
              s.open_l = s.open_r = h_lerp(s.open_l, 0.95f, 0.25f);
              s.px = h_lerp(s.px, s.tx, 0.35f);
              s.py = h_lerp(s.py, s.ty, 0.35f);
              if (s.t >= s.dur) goto_mode(IDLE, h_frand(s.rng, 1.0f, 2.0f));
            } break;

            case SQUINT: {
              float k = h_smooth01(s.t / s.dur);
              float mid = (k < 0.5f) ? (k*2.0f) : (1.0f - (k-0.5f)*2.0f);
              float target = h_lerp(0.55f, 0.25f, mid);
              s.open_l = s.open_r = h_lerp(s.open_l, target, 0.6f);
              s.px = h_lerp(s.px, 0.0f, 0.2f);
              s.py = h_lerp(s.py, 0.0f, 0.2f);
              if (s.t >= s.dur) goto_mode(IDLE, h_frand(s.rng, 1.0f, 2.0f));
            } break;

            case SURPRISED: {
              s.open_l = s.open_r = h_lerp(s.open_l, 1.0f, 0.5f);
              s.px = h_lerp(s.px, h_frand(s.rng, -0.12f, 0.12f), 0.25f);
              s.py = h_lerp(s.py, h_frand(s.rng, -0.04f, 0.02f),  0.25f);
              if (s.t >= s.dur) goto_mode(IDLE, h_frand(s.rng, 1.0f, 2.0f));
            } break;
          }

          // whole-eye drift
          int eye_shift_x = (int)(R * 0.20f * s.px);
          int eye_shift_y = (int)(R * 0.12f * s.py);
          int lx = base_lx + eye_shift_x;
          int rx = base_rx + eye_shift_x;
          int ey = base_ey + eye_shift_y;

          auto open_to_px = [&](float o)->int { o = h_clamp01(o); return (int)(R * o); };
          int open_px_l = open_to_px(s.open_l);
          int open_px_r = open_to_px(s.open_r);

          float max_off = R * 0.38f * ((s.open_l + s.open_r)*0.5f);
          float jx = 0.0f, jy = 0.0f; // micro-saccades
          if (s.mode == IDLE || s.mode == LOOK || s.mode == SURPRISED) {
            jx = h_frand(s.rng, -0.03f, 0.03f);
            jy = h_frand(s.rng, -0.03f, 0.03f);
          }
          int ix_l = lx + (int)(h_clampf(s.px + jx, -1.0f, 1.0f) * max_off);
          int iy_l = ey + (int)(h_clampf(s.py + jy, -1.0f, 1.0f) * max_off);
          int ix_r = rx + (int)(h_clampf(s.px + jx, -1.0f, 1.0f) * max_off);
          int iy_r = ey + (int)(h_clampf(s.py + jy, -1.0f, 1.0f) * max_off);

          // LED pulse (triangle wave)
          float beat = 0.35f + 0.65f * h_tri01(now, 1600);
          int led_g = (int)(100 + 120 * beat);
          int led_r = std::max(2, R / 6);
          int led_x = cx, led_y = ey + R + 8;

          // early-out if nothing changed (incl. LED)
          if (lx == s.prev_lx && rx == s.prev_rx && ey == s.prev_ey &&
              open_px_l == s.prev_open_px_l && open_px_r == s.prev_open_px_r &&
              ix_l == s.prev_ix_l && iy_l == s.prev_iy_l &&
              ix_r == s.prev_ix_r && iy_r == s.prev_iy_r &&
              led_g == s.prev_led_g) {
            s.next_ms = now + FRAME_MS_IDLE;
            return;
          }

          // erase only old eye regions + old LED box
          auto erase_eye_box = [&](int ex, int eyc){
            int box = (R + 2);
            it.filled_rectangle(ex - box, eyc - box, box*2, box*2, Color::BLACK);
          };
          if (s.prev_lx != -9999) {
            erase_eye_box(s.prev_lx, s.prev_ey);
            erase_eye_box(s.prev_rx, s.prev_ey);
            int lbox = led_r + 2;
            it.filled_rectangle(led_x - lbox, (s.prev_ey + R + 8) - lbox, lbox*2, lbox*2, Color::BLACK);
          }

          // draw one eye (reduced calls, no trig)
          auto draw_eye = [&](int ex, int eyc, int open_px, int ix, int iy){
            it.filled_circle(ex, eyc, R, Color::WHITE);
            int cover = R - open_px;
            if (cover > 0) {
              it.filled_rectangle(ex - R - 1, eyc - R - 1, (R*2)+2, cover + 1, Color::BLACK);
              it.filled_rectangle(ex - R - 1, eyc + open_px, (R*2)+2, R - open_px + 1, Color::BLACK);
            }
            int iris_r  = std::max(2, (int)(R * 0.46f));
            int pupil_r = std::max(1, (int)(R * 0.18f));
            Color iris_in(0x80,0xc8,0xff), iris_outline(0x30,0x70,0xa0);
            it.filled_circle(ix, iy, iris_r, iris_in);
            it.circle(ix, iy, iris_r, iris_outline);
            // 4 spokes (no trig)
            it.line(ix, iy, ix + (iris_r-2), iy, iris_outline);
            it.line(ix, iy, ix - (iris_r-2), iy, iris_outline);
            it.line(ix, iy, ix, iy + (iris_r-2), iris_outline);
            it.line(ix, iy, ix, iy - (iris_r-2), iris_outline);
            it.filled_circle(ix, iy, pupil_r, Color::BLACK);
            it.filled_circle(ix - pupil_r/2, iy - pupil_r, std::max(1, pupil_r/3), Color::WHITE);
            it.circle(ex, eyc, R, Color(0x90,0x90,0x90));
          };

          draw_eye(lx, ey, open_px_l, ix_l, iy_l);
          draw_eye(rx, ey, open_px_r, ix_r, iy_r);

          // LED
          it.filled_circle(led_x, led_y, led_r, Color((uint8_t)30, (uint8_t)led_g, (uint8_t)255));

          // save + cadence
          bool moving = (s.mode != IDLE);
          s.prev_lx = lx; s.prev_rx = rx; s.prev_ey = ey;
          s.prev_open_px_l = open_px_l; s.prev_open_px_r = open_px_r;
          s.prev_ix_l = ix_l; s.prev_iy_l = iy_l; s.prev_ix_r = ix_r; s.prev_iy_r = iy_r;
          s.prev_led_g = led_g;
          s.next_ms = now + (moving ? FRAME_MS_FAST : FRAME_MS_IDLE);
